#!/usr/bin/env python
# encoding: utf-8
"""
yarn.py - the Tin Can server.

Initializes the tornado server, sets the routing paths, initializes the model,
etc.

Created by Drew Harry on 2010-06-09.
Copyright (c) 2010 MIT Media Lab. All rights reserved.
"""

import logging
import os.path

import tornado.httpserver
import tornado.ioloop
import tornado.web
from tornado.options import define, options

import simplejson as json


import state
from model import *
from event import *

define("port", default=8888, help="run on the given port", type=int)



class YarnApplication(tornado.web.Application):
    def __init__(self):
        
        handlers = [
            (r"/rooms/list", RoomsHandler),
            (r"/users/connected", ConnectedUsersHandler),
            (r"/users/disconnected", DisconnectedUsersHandler),
            (r"/users/", AllUsersHandler),
            (r"/connect/", ConnectionHandler),
            (r"/connect/ping/", PingHandler),
            (r"/connect/test", ConnectTestHandler),
            (r"/users/choose", ChooseUsersHandler)
            ]
        
        settings = dict(
            # using the chatdemo secret for now - this really should be
            # loaded out of a configuration file, so we don't have to check
            # it into the repository. Don't trust this for ANYTHING.
            template_path=os.path.join(os.path.dirname(__file__), "templates"),
            static_path=os.path.join(os.path.dirname(__file__), "static"),
        )
        
        tornado.web.Application.__init__(self, handlers, **settings)

# TODO Is there a way to make json.dump default to using YarnModelJSONEncoder?
# It's really annoying to have to specify it every time I need to dump
# something.
class RoomsHandler(tornado.web.RequestHandler):
    def get(self):
        """Returns a list of rooms."""
        self.write(json.dumps(state.rooms, cls=YarnModelJSONEncoder))

class AllUsersHandler(tornado.web.RequestHandler):
    def get(self):
        self.write(json.dumps(state.users, cls=YarnModelJSONEncoder))

class ConnectedUsersHandler(tornado.web.RequestHandler):
    def get(self):
        self.write(json.dumps(state.get_logged_in_users(), cls=YarnModelJSONEncoder))

class DisconnectedUsersHandler(tornado.web.RequestHandler):
    def get(self):
        result = json.dumps(state.get_logged_out_users(), cls=YarnModelJSONEncoder)
        logging.info("writing result: " + str(result))
        self.write(result)
        logging.info("After writing to page.")
        self.finish()

class ConnectTestHandler(tornado.web.RequestHandler):
    def get(self):
        self.render("connect.html", users=state.get_logged_out_users(), rooms=state.rooms)

class ConnectionHandler(tornado.web.RequestHandler):
    """Manage the persistent connections that all clients have."""
    
    @tornado.web.asynchronous
    def get(self):
        # We're going to treat this pretty much like the toqbot
        # infrastructure -- a client will open a connection to this url and
        # we'll hold on to it until we have something to send to that client.
        #
        # We'll use per-user message queues. Those queues
        # are owned by the user objects, and whenever someone connects we
        # empty the message queue into the connection and finish it, 
        # or we hold that connection open.
        #
        # We're going to need userUUIDs and meetingUUIDs.
        # I'm concerned with having to send this stuff around all the time,
        # these UUIDs are so huge that it gets a bit ugly looking. But
        # I guess it's mostly in the background? We'll roll with it for now.
        # Most of this will get pushed into cookies anyway, I think? We'll
        # have to figure out the multiple-connections-at-once case later. 
        
        # because arguments get treated as UTF-8 inputs, we need to 
        # re-encode back down to ASCII so we can compare. We can trust that
        # these are fundamentally ASCII to begin with because they're IDs
        # generated by the client, not user-entered text.
        userUUID = self.get_argument("user").encode('ascii')
        user = state.get_obj(userUUID, User)
        
        if user != None:
            logging.debug("Found a user '%s' for id (%s)"% (user.name, userUUID))
            user.setConnection(self)            
        else:
            raise HTTPError("400", "Specified user UUID (%s), is not a known user id." % userUUID)
        

class PingHandler(tornado.web.RequestHandler):
    """A testing handler to test connection management issue."""
    
    def get(self):
        # make a trivial ping event. 
        event = Event("PING", None, None)
        
        state.send_event_to_users(state.get_logged_in_users(), event)
        
class ChooseUsersHandler(tornado.web.RequestHandler):
    def get(self):
        self.render("login.html")

# Set up the routing tables for the application.
# For now, they're really simple - one for getting information about rooms,
# one for getting information about users (and registering a new user),
# and one for managing persistent connections. 
#
# I'd like to be able to merge all the users handlers into one - not sure
# yet how to do that.

if __name__ == '__main__':
    tornado.options.parse_command_line()
    
    # This just populates the state with some trial data to have something
    # to work with and test.
    state.init_test()
    
    http_server = tornado.httpserver.HTTPServer(YarnApplication())
    
    # defaults to 8888
    http_server.listen(options.port)
    tornado.ioloop.IOLoop.instance().start()

